{"version":3,"file":"bundle.js","sources":["../src/baseType.ts","../src/typeAsserts.ts","../src/functionType.ts","../src/classType.ts","../src/interfaceAndGeneric.ts","../index.ts"],"sourcesContent":["const baseType = function () {\n    //基本类型：string number boolean\n    const name: string = 'zz';\n    const age: number = 20;\n    const isMale: boolean = false;\n\n\n    //类型推导：这里ts会推导类型\n    let gender = 'female';\n    // gender = 1; //gender被推导为string类型，此处类型不对\n    console.log(name, age);\n\n\n    // 父子关系：子集可以赋值给父集\n    let s1: string = 'a';\n    // let s2: string = new String('a');//new String是class类型，不能赋值给string类型\n    let s3: String = '1';//子集可以赋值给父集\n    let s4: String = new String('1');\n\n    //数组\n    //强类型中，数组中元素的类型需要一致，但js可以随意\n    let arr1: number[] = [1, 2, 3];\n    let arr2: Array<number> = [1, 2, 3];//泛型方式\n    let arr3: (number | string)[] = [1, '1'];//使用联合类型，实现数组元素可以有多种类型\n    // arr3.push(true);//报类型错误\n\n\n    //元组 tuple\n    //元组与数组的区别是，元组限制了特定位置的类型，顺序、位置和数量都必须与类型定义一致\n    let tuple1: [string, number] = ['1', 1]\n    // let tuple2: [string, number] = ['1'];//数量不对\n    // let tuple3: [string, number] = [2, 1];//类型不对\n    //可以增加string, number类型的元素，但是访问时会报错\n    tuple1.push(2);\n    // tuple1[2];//Tuple type '[string, number]' of length '2' has no element at index '2'\n    console.log('tuple', tuple1);\n\n\n    // enum 枚举，自带类型的对象，维护一组常量\n    // 约定一组格式：状态码 权限 数据格式 标志位\n    // 枚举内的值，默认从0开始递增；可以赋予其他值，后面的变量值默认是上一个值加1\n    // （异构枚举）如果上一个值不是数字，那需要重新给当前变量初始化一个值\n    enum STATUS1 {\n        'OK',\n        'NO_OK',\n    };\n    enum STATUS2 {\n        'OK' = 2,\n        'NO_OK',\n    };\n    enum STATUS3 {\n        'OK',\n        'NO_OK' = 'no_ok',\n        'NOT_FOUND' = 2\n    };\n    // 上面几个枚举会被编译成对象\n    // 但常量枚举不会被编译成对象，rollup在编译时，只会把用到的枚举值直接取出\n    // 常量枚举更常用，更加节省空间\n    const enum STATUS4 {\n        'OK',\n        'NO_OK',\n        'NOT_FOUND'\n    }\n    const r = STATUS4['OK'];\n    console.log(r);\n\n\n    // null undefined\n    // tsconfig.json中\"strictNullChecks\"设置为false时，null undefined类型可以赋值给任何类型\n    const u: undefined = undefined;\n    const n: null = null;\n\n\n\n    // void 空类型 一般表示函数的返回值\n    // undefined可以赋值给void（undefined是void的子类型）\n    function a(): void {\n        // return undefined;\n        return;\n    }\n\n\n    // never 永远达到不了的地方\n    function whileTrue(): never {\n        while (true) { }//函数无法达到执行完毕的状态\n    }\n    function throwError(): never {\n        throw Error();//出错无法执行完毕\n    }\n    //如果if/else条件都走完了，没有遗漏的，后面的类型就是never（完整性保护）\n    // 111 [1,1,1]\n    // '111' ['1','1','1']\n    // true ['t','r','u','e']\n    function toArray(val: number | string | boolean) {\n        if (typeof val === 'number') {\n            return val.toString().split('').map(Number)\n        }\n        if (typeof val === 'string') {\n            return val.split('')\n        }\n        if (typeof val === 'boolean') {\n            return val.toString().split('')\n        }\n        //如果上述条件没有枚举玩，这里会报错\n        const n: never = val;\n        // 可以改为一个校验方法\n        validateCheck(val);//代码的完整性保护\n    }\n    function validateCheck(v: never) { }\n\n\n    // any 任何类型，只在迫不得已的情况下用，会导致类型检测丧失\n    let a1: any = 1;\n    a1 = '1';\n\n    //unknown 未知类型\n\n    //object 引用类型\n    function create(val: object) { }\n    create({});\n    create([]);\n    create(function () { });\n    // create(1);//报错\n\n\n    // symbol bigInt\n    const s: symbol = Symbol();\n    const b = BigInt(1);//需要把target改为\"ES2020\"之后，或者添加lib: [\"ES2020\", \"DOM\"]，（console.log属于DOM）\n\n\n}\nexport default baseType","const typeAsserts = function () {\n    // 声明变量时，如果没有标识类型，它是any类型，值是undefined\n    let a;\n\n    // const时常量，意味着值不会改变，它的类型是字面量\n    const c = 1;\n    const c1: 1 = 1;\n    const str: 'a' = 'a';\n\n\n    // 断言\n    let strOrNum: string | number;\n    // 在使用联合类型的时候，通常会先赋值，再使用\n    // strOrNum = 1;\n    // strOrNum.toFixed();\n    // strOrNum = '1';\n    // strOrNum.charCodeAt(0);\n    // 对于某些情况下，变量的值已确定，可以使用断言，同时使用非空断言!，此时ts不会进行类型检测了\n    (strOrNum! as number).toFixed(1);\n    (<number>strOrNum!).toFixed(1);\n\n    let ele = document.getElementById('app');\n    ele!.style.background = '';\n    //js中`?`是取值操作，不能赋值\n    // ele?.style.background = '';\n\n    // 值 as xxx 或者 <xxx>值 一般用于联合类型断言，将大范围的类型，断言成子类型\n\n    // 双重断言，一般不建议使用，可以断言为任意类型\n    (strOrNum! as unknown as boolean);\n\n\n    // 类型别名，构建可复用类型\n    type Direction = 'up' | 'down';\n    let d: Direction = 'up';\n    let up: 'down' = d as 'down';\n}\nexport default typeAsserts;","export default function () {\n    // 函数中的类型\n    // 参数、返回值\n    type Fn1 = (a: number, b: string) => number | string;\n    type Fn2 = { (a: number, b: string): number | string };\n    function sum1(a: number, b: string): number | string {\n        return a + b;\n    }\n    const sum2: Fn1 = function (a, b) {\n        return a + b;\n    }\n    const sum3: Fn2 = function (a, b) {\n        return a + b;\n    }\n    sum1(1, '1')\n    sum2(1, '1')\n    sum3(1, '1');\n\n    // ? 可选参数，必须放在后面，且不能有默认值\n    const sum4 = function (a: string, b?: string, c?: number) {\n        return a + b\n    }\n    sum4('1');\n\n\n    // 默认值\n    const sum5 = function (a: string, b: string = '1') {\n        return a + b\n    }\n    sum5('1');\n\n    // 参数this问题\n    // 尽量不采用this来作为函数的上下文，this的缺陷就是类型推导问题\n    // 如果想限制this类型，那么需要手动置顶this类型\n    const person = { name: 'z', age: 30 };\n    type IPerson = typeof person;//提取对象的类型为IPerson，type类型会提升到顶部\n    type IKeys = keyof IPerson;//提取类型的key作为联合类型\n    // this放在第一个参数，定义类型；不是形参\n    function getValue(this: IPerson, key: IKeys) {\n        return this[key]\n    }\n    getValue.call(person, 'name');\n\n\n    // 参数不定项\n    function sum6(...args: number[]): number {\n        return args.reduce((memo, cur) => (memo += cur, memo), 0)\n    }\n    sum6(1, 2, 3);\n\n\n    // 函数重载（类型重载）\n    function toArray(value: string): string[];//具体的某一种方案\n    function toArray(value: number): number[];\n    //上面的声明仅仅是类型重载\n    function toArray(value: string | number): string[] | number[] {//所有的实现\n        if (typeof value === 'number') {\n            return value.toString().split('').map(Number)\n        }\n        if (typeof value === 'string') {\n            return value.split('')\n        }\n        return []\n    }\n\n    let arr1 = toArray('aaa');\n    let arr2 = toArray(111);\n}","export default function () {\n    //类 \n    // 构造函数、属性、方法访问器，静态相关配置\n\n    class Circle {\n        // 给这个类声明属性\n        public x: number;\n        public y: number;\n        constructor(x: number, y: number = 200) {\n            this.x = x;\n            this.y = y;\n        }\n    }\n\n    // public 公开属性，类的实例、类内部、子类都可以访问\n    // protected 自己和子类内部能访问，实例不能访问\n    // private 私有的，只有自己内部能访问，实例不能访问\n    // readonly 表示只读，初始化之后，不能被修改\n    let circle = new Circle(100, 100);\n\n    class Animal {\n        constructor(public name: string) {\n            //实例属性\n            this.name = name;\n        }\n        // 原型方法 这里的void表示不关心返回值\n        changeName(value: string, age: number): void {\n            this.name = value;\n        }\n        // 原型属性，需要通过访问器实现\n        get aliasName() {\n            return '$' + this.name\n        }\n        set aliasName(name: string) {\n            this.name = name;\n        }\n        //静态属性\n        static a = 1;\n        static getA() {\n            // 静态方法中的this，指的是类本身\n            return this.a;\n        }\n    }\n\n    // super在构造函数中，指向父类；在原型方法中，指向的是父类的原型\n    class Cat extends Animal {\n        constructor(name: string, public readonly age: number) {\n            super(name);//Animal.call(this)\n            this.age = age;\n            // this.name = '3'\n        }\n        // 重写父类的方法，参数类型要兼容，保证子类调用父类的时候参数一致\n        changeName(value: string) {\n            super.changeName(value, 10)\n            // this.name = value;\n            return 'a'\n        }\n    }\n    const tom = new Cat('tom', 3);\n    tom.changeName('jerry');\n    //子类型可以赋值给父类型\n    let a: Animal = tom;\n    // a.age;//但此时a不能取到子类的属性\n\n    class A {\n        // private 只能在类内部访问，子类不能访问，此时A不能被继承，也不能被new\n        // protected 只能在类和子类内部访问，此时A不能被new\n        protected constructor() { }\n    }\n    class B extends A {\n        constructor() {\n            super()\n        }\n    }\n\n    // private constructor可以在单例模式中使用，不在外部使用new关键字创建实例：\n    class Singleton {\n        static instance = new Singleton();\n        private constructor() { };\n        static getInstance() {\n            return this.instance\n        }\n    }\n    let instance = Singleton.getInstance();\n\n    // 不能被new的类，叫抽象类，在ts中使用 abstract 关键字\n    // 抽象类 可以含有非抽象的方法和属性\n    // 抽象类可以被继承\n    {\n        abstract class Animal {\n            public abstract a: string;//抽象属性\n            drink() {//非抽象方法\n                console.log('喝水')\n            }\n            abstract eat(): void;//抽象的方法，父类没有实现，子类必须实现\n        }\n        class Cat extends Animal {\n            public a!: string;\n            eat(): void {\n                console.log('吃东西')\n            }\n        }\n    }\n}","\nexport default function () {\n    // 接口和泛型\n    // 接口： 描述数据的结构或形状，定义好结构，再去实现\n\n    // type 和 interface 区别\n    // 一般情况下，描述对象，类，用interface更多\n    // type可以快速声明类型： 联合类型，工具类型 只能用type\n    // type 不能重名，interface可以\n    // 开发中，能用type就用type，复杂类型采用type\n\n    // 接口可以描述对象结构\n    interface IPerson {\n        username: 'abc',//字面量类型\n        age: number,\n    }\n    let person: IPerson = {\n        username: 'abc',\n        age: 20\n    }\n    interface IDriver extends IPerson {\n        driveAge: number;\n    }\n    let driver: IDriver = {\n        username: 'abc',\n        age: 30,\n        driveAge: 4\n    }\n    // 赋值的时候，会产生兼容性，子类型可以赋值给父类型\n    person = driver;\n    // driver = person;//反过来不行\n\n\n    // 接口可以描述函数\n    interface ICounter {\n        (): number;\n        count: number;\n    }\n    // 函数有类型定义的时候，只能用const声明，表示此值不能背修改\n    const counter: ICounter = () => {\n        return counter.count++\n    }\n    counter.count = 0;\n\n\n    interface IVeg {\n        readonly name: string;//readonly 只读属性\n        taste: string;\n        size: number;\n    }\n    // 同名的接口，会合并，在自定义类型的时候会使用\n    // interface IVeg {\n    //     color?: string;\n    // }\n    // 或者扩展一个新类型：\n    interface IVegetable extends IVeg {\n        color?: string;\n        [key: string | number | symbol]: any\n    }\n    const veg: IVegetable = {\n        name: '西红柿',\n        taste: '甜',\n        size: 50,\n        a: 1,\n        0: 1,\n        [Symbol()]: 'a'\n    }\n    interface IArray {\n        [key: number]: any;\n    }\n    let arr1: IArray = [1, '2'];\n    let arr2: IArray = { 1: 'a' };\n\n    //接口组合\n    interface ResData {\n        username: string;\n        token: string;\n    }\n    interface ReturnVal {\n        code: number;\n        data: ResData;\n    }\n\n    //通过索引访问符，来获取内部类型\n    type ICode = ReturnVal['code'];//取 值的类型\n    type IUsername = ReturnVal['data']['username'];//取 值的类型\n    type values = ReturnVal[keyof ReturnVal];//获取所有 值的类型\n    type keys = keyof ReturnVal;//获取类型的所有key\n    let k1: keys = 'code';\n    let k2: values = 1;\n    let k3: values = {\n        username: 'a',\n        token: 'a'\n    };\n\n\n\n    // 接口可以被实现，通过类实现\n    // 接口可以继承多个接口(extends)：interface a extends IB,IC\n    // 类可以实现多个接口\n    interface Speakable {\n        // speak(): void;// 这是原型方法\n        speak: () => void;// 这是实例方法\n    }\n    interface SpeakChinese {\n        speakChinese(): void\n    }\n    class Speaker implements Speakable, SpeakChinese {\n        public speak: () => void;\n        constructor() {\n            this.speak = () => null;\n        }\n        speakChinese(): void {\n            throw new Error(\"Method not implemented.\");\n        }\n    }\n\n\n    // 如何表示函数的参数是一个类\n    class Dog {\n        public a: number = 1\n    }\n    class Cat {\n        public a: number = 1\n        public b: number = 1\n    }\n    {\n        // 类类型，不能描述类本身，描述的是实例\n        // 类的类型，需要通过typeof来取\n        function createInstance(clazz: typeof Dog) {\n            return new clazz()\n        }\n        const instance1 = createInstance(Dog);\n        // instance2也是Dog类型（鸭子类型检测）\n        const instance2 = createInstance(Cat);\n    }\n    {\n        // 泛型，函数的形式参数，刚开始类型不确定，使用的时候才能确定\n        // 描述一个构造函数，构造函数返回的类型是T： { new (): T }\n        // interface IClazz<T> {\n        //     new(): T\n        // }\n        // 用type描述构造函数\n        type IClazz<T> = new () => T\n        // type IClazz<T> = new (name: string) => T\n        function createInstance<T>(clazz: IClazz<T>) {\n            return new clazz()\n        }\n        // function createInstance<T>(clazz: new () => T) {\n        //     return new clazz()\n        // }\n        // const instance1 = createInstance<Dog>(Dog);\n        // const instance2 = createInstance<Cat>(Cat);\n        // 可以省略，ts会推导\n        const instance1 = createInstance(Dog);\n        const instance2 = createInstance(Cat);\n    }\n\n\n\n\n\n    // ------------------- generic 泛型 -------------------\n    // 泛型可以用于 函数、接口、类、type\n    // 刚开始类型不确定，使用的时候才能确定\n\n    // const createArr = <T>(times: number, val: T) => {\n\n    // }\n    function createArr<T>(times: number, val: T) {\n        return Array.from({ length: times }).fill(val) as T[]\n    }\n\n    let arr3 = createArr<string>(2, 'a');\n    let arr4 = createArr<number>(2, 1);\n\n    //值的交换\n    function swap<T, K>(tuple: [T, K]): [K, T] {\n        return [tuple[1], tuple[0]]\n    }\n    const r = swap([1, 'a']);\n\n    // IForEach<T> 表示使用接口的时候确定类型\n    // <T>():void 表示使用这个函数的时候确定类型\n    // interface IForEach {\n    //     <T>(arr: T[], cb: (val: T) => void): void\n    // }\n    // type方式\n    type ICallback<T> = (val: T) => void;\n    type IForEach = <T>(arr: T[], cb: ICallback<T>) => void;\n    const forEach: IForEach = (arr, cb) => {\n        for (let i = 0; i < arr.length; i++) {\n            cb(arr[i])\n        }\n    }\n    forEach(['a', 2, 3], function (val) {\n        console.log(val)\n    });\n\n    {\n        // 泛型的默认值\n        interface APIResponse<T = any> {\n            error: number;\n            message?: string;\n            data: T;\n        }\n        interface LoginInfo {\n            username: string;\n            token: string;\n        }\n        function login(): APIResponse<LoginInfo> {\n            return {\n                error: 0,\n                message: 'success',\n                data: {\n                    username: 'a',\n                    token: 'a'\n                }\n            }\n        }\n        let r = login();\n\n\n        // 联合类型中的泛型\n        type IUnion<T = boolean> = T | string | number;\n        type t1 = IUnion;\n        type t2 = IUnion<string[] | number[]>;\n\n        //泛型是用户传递的类型，但在使用泛型的时候，都要添加泛型约束\n        function getVal<T>(val: T): T {\n            // return val + val;//在使用泛型的时候，不能直接做运算，因为无法保证泛型的结果\n            return val\n        }\n        getVal(1);\n\n\n        //如何限制调用getVal时，只能传string或number？\n        //extends约束T需要是string | number的子类型\n        function getVal1<T extends string | number>(val: T): T {\n            // return val + val;//在使用泛型的时候，不能直接做运算，因为无法保证泛型的结果\n            return val\n        }\n        //getVal1限制泛型只能是string | number\n        // getVal1(true)\n        getVal1(1)\n    }\n\n    {\n        //类中的泛型\n        //求一个数组中的最大值\n        class MyList<T extends string | number> {\n            private arr: T[] = [];\n            add(val: T) {\n                this.arr.push(val)\n            };\n            getMax(): T {\n                //业务逻辑\n                return this.arr[0];\n            }\n        }\n\n        const list = new MyList<number>\n        list.add(1);\n        list.add(100);\n        list.add(200);\n        list.getMax();\n\n\n\n        //泛型可以使用的场景： 函数，对象，类\n        //泛型有约束和默认值\n    }\n}\n","import baseType from './src/baseType';\nimport typeAsserts from './src/typeAsserts';\nimport functionType from './src/functionType';\nimport classType from './src/classType';\nimport interfaceAndGeneric from './src/interfaceAndGeneric';\n\nbaseType()\ntypeAsserts()\nfunctionType()\nclassType()\ninterfaceAndGeneric()"],"names":[],"mappings":"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"}