{"version":3,"file":"bundle.js","sources":["../src/baseType.ts","../src/typeAsserts.ts","../src/functionType.ts","../src/classType.ts","../index.ts"],"sourcesContent":["const baseType = function () {\n    //基本类型：string number boolean\n    const name: string = 'zz';\n    const age: number = 20;\n    const isMale: boolean = false;\n\n\n    //类型推导：这里ts会推导类型\n    let gender = 'female';\n    // gender = 1; //gender被推导为string类型，此处类型不对\n    console.log(name, age);\n\n\n    // 父子关系：子集可以赋值给父集\n    let s1: string = 'a';\n    // let s2: string = new String('a');//new String是class类型，不能赋值给string类型\n    let s3: String = '1';//子集可以赋值给父集\n    let s4: String = new String('1');\n\n    //数组\n    //强类型中，数组中元素的类型需要一致，但js可以随意\n    let arr1: number[] = [1, 2, 3];\n    let arr2: Array<number> = [1, 2, 3];//泛型方式\n    let arr3: (number | string)[] = [1, '1'];//使用联合类型，实现数组元素可以有多种类型\n    // arr3.push(true);//报类型错误\n\n\n    //元组 tuple\n    //元组与数组的区别是，元组限制了特定位置的类型，顺序、位置和数量都必须与类型定义一致\n    let tuple1: [string, number] = ['1', 1]\n    // let tuple2: [string, number] = ['1'];//数量不对\n    // let tuple3: [string, number] = [2, 1];//类型不对\n    //可以增加string, number类型的元素，但是访问时会报错\n    tuple1.push(2);\n    // tuple1[2];//Tuple type '[string, number]' of length '2' has no element at index '2'\n    console.log('tuple', tuple1);\n\n\n    // enum 枚举，自带类型的对象，维护一组常量\n    // 约定一组格式：状态码 权限 数据格式 标志位\n    // 枚举内的值，默认从0开始递增；可以赋予其他值，后面的变量值默认是上一个值加1\n    // （异构枚举）如果上一个值不是数字，那需要重新给当前变量初始化一个值\n    enum STATUS1 {\n        'OK',\n        'NO_OK',\n    };\n    enum STATUS2 {\n        'OK' = 2,\n        'NO_OK',\n    };\n    enum STATUS3 {\n        'OK',\n        'NO_OK' = 'no_ok',\n        'NOT_FOUND' = 2\n    };\n    // 上面几个枚举会被编译成对象\n    // 但常量枚举不会被编译成对象，rollup在编译时，只会把用到的枚举值直接取出\n    // 常量枚举更常用，更加节省空间\n    const enum STATUS4 {\n        'OK',\n        'NO_OK',\n        'NOT_FOUND'\n    }\n    const r = STATUS4['OK'];\n    console.log(r);\n\n\n    // null undefined\n    // tsconfig.json中\"strictNullChecks\"设置为false时，null undefined类型可以赋值给任何类型\n    const u: undefined = undefined;\n    const n: null = null;\n\n\n\n    // void 空类型 一般表示函数的返回值\n    // undefined可以赋值给void（undefined是void的子类型）\n    function a(): void {\n        // return undefined;\n        return;\n    }\n\n\n    // never 永远达到不了的地方\n    function whileTrue(): never {\n        while (true) { }//函数无法达到执行完毕的状态\n    }\n    function throwError(): never {\n        throw Error();//出错无法执行完毕\n    }\n    //如果if/else条件都走完了，没有遗漏的，后面的类型就是never（完整性保护）\n    // 111 [1,1,1]\n    // '111' ['1','1','1']\n    // true ['t','r','u','e']\n    function toArray(val: number | string | boolean) {\n        if (typeof val === 'number') {\n            return val.toString().split('').map(Number)\n        }\n        if (typeof val === 'string') {\n            return val.split('')\n        }\n        if (typeof val === 'boolean') {\n            return val.toString().split('')\n        }\n        //如果上述条件没有枚举玩，这里会报错\n        const n: never = val;\n        // 可以改为一个校验方法\n        validateCheck(val);//代码的完整性保护\n    }\n    function validateCheck(v: never) { }\n\n\n    // any 任何类型，只在迫不得已的情况下用，会导致类型检测丧失\n    let a1: any = 1;\n    a1 = '1';\n\n    //unknown 未知类型\n\n    //object 引用类型\n    function create(val: object) { }\n    create({});\n    create([]);\n    create(function () { });\n    // create(1);//报错\n\n\n    // symbol bigInt\n    const s: symbol = Symbol();\n    const b = BigInt(1);//需要把target改为\"ES2020\"之后，或者添加lib: [\"ES2020\", \"DOM\"]，（console.log属于DOM）\n\n\n}\nexport default baseType","const typeAsserts = function () {\n    // 声明变量时，如果没有标识类型，它是any类型，值是undefined\n    let a;\n\n    // const时常量，意味着值不会改变，它的类型是字面量\n    const c = 1;\n    const c1: 1 = 1;\n    const str: 'a' = 'a';\n\n\n    // 断言\n    let strOrNum: string | number;\n    // 在使用联合类型的时候，通常会先赋值，再使用\n    // strOrNum = 1;\n    // strOrNum.toFixed();\n    // strOrNum = '1';\n    // strOrNum.charCodeAt(0);\n    // 对于某些情况下，变量的值已确定，可以使用断言，同时使用非空断言!，此时ts不会进行类型检测了\n    (strOrNum! as number).toFixed(1);\n    (<number>strOrNum!).toFixed(1);\n\n    let ele = document.getElementById('app');\n    ele!.style.background = '';\n    //js中`?`是取值操作，不能赋值\n    // ele?.style.background = '';\n\n    // 值 as xxx 或者 <xxx>值 一般用于联合类型断言，将大范围的类型，断言成子类型\n\n    // 双重断言，一般不建议使用，可以断言为任意类型\n    (strOrNum! as unknown as boolean);\n\n\n    // 类型别名，构建可复用类型\n    type Direction = 'up' | 'down';\n    let d: Direction = 'up';\n    let up: 'down' = d as 'down';\n}\nexport default typeAsserts;","export default function () {\n    // 函数中的类型\n    // 参数、返回值\n    type Fn1 = (a: number, b: string) => number | string;\n    type Fn2 = { (a: number, b: string): number | string };\n    function sum1(a: number, b: string): number | string {\n        return a + b;\n    }\n    const sum2: Fn1 = function (a, b) {\n        return a + b;\n    }\n    const sum3: Fn2 = function (a, b) {\n        return a + b;\n    }\n    sum1(1, '1')\n    sum2(1, '1')\n    sum3(1, '1');\n\n    // ? 可选参数，必须放在后面，且不能有默认值\n    const sum4 = function (a: string, b?: string, c?: number) {\n        return a + b\n    }\n    sum4('1');\n\n\n    // 默认值\n    const sum5 = function (a: string, b: string = '1') {\n        return a + b\n    }\n    sum5('1');\n\n    // 参数this问题\n    // 尽量不采用this来作为函数的上下文，this的缺陷就是类型推导问题\n    // 如果想限制this类型，那么需要手动置顶this类型\n    const person = { name: 'z', age: 30 };\n    type IPerson = typeof person;//提取对象的类型为IPerson，type类型会提升到顶部\n    type IKeys = keyof IPerson;//提取类型的key作为联合类型\n    // this放在第一个参数，定义类型；不是形参\n    function getValue(this: IPerson, key: IKeys) {\n        return this[key]\n    }\n    getValue.call(person, 'name');\n\n\n    // 参数不定项\n    function sum6(...args: number[]): number {\n        return args.reduce((memo, cur) => (memo += cur, memo), 0)\n    }\n    sum6(1, 2, 3);\n\n\n    // 函数重载（类型重载）\n    function toArray(value: string): string[];//具体的某一种方案\n    function toArray(value: number): number[];\n    //上面的声明仅仅是类型重载\n    function toArray(value: string | number): string[] | number[] {//所有的实现\n        if (typeof value === 'number') {\n            return value.toString().split('').map(Number)\n        }\n        if (typeof value === 'string') {\n            return value.split('')\n        }\n        return []\n    }\n\n    let arr1 = toArray('aaa');\n    let arr2 = toArray(111);\n}","export default function () {\n    //类 \n    // 构造函数、属性、方法访问器，静态相关配置\n\n    class Circle {\n        // 给这个类声明属性\n        public x: number;\n        public y: number;\n        constructor(x: number, y: number = 200) {\n            this.x = x;\n            this.y = y;\n        }\n    }\n\n    // public 公开属性，类的实例、类内部、子类都可以访问\n    // protected 自己和子类内部能访问，实例不能访问\n    // private 私有的，只有自己内部能访问，实例不能访问\n    // readonly 表示只读，初始化之后，不能被修改\n    let circle = new Circle(100, 100);\n\n    class Animal {\n        constructor(public name: string) {\n            //实例属性\n            this.name = name;\n        }\n        // 原型方法 这里的void表示不关心返回值\n        changeName(value: string, age: number): void {\n            this.name = value;\n        }\n        // 原型属性，需要通过访问器实现\n        get aliasName() {\n            return '$' + this.name\n        }\n        set aliasName(name: string) {\n            this.name = name;\n        }\n        //静态属性\n        static a = 1;\n        static getA() {\n            // 静态方法中的this，指的是类本身\n            return this.a;\n        }\n    }\n\n    // super在构造函数中，指向父类；在原型方法中，指向的是父类的原型\n    class Cat extends Animal {\n        constructor(name: string, public readonly age: number) {\n            super(name);//Animal.call(this)\n            this.age = age;\n            // this.name = '3'\n        }\n        // 重写父类的方法，参数类型要兼容，保证子类调用父类的时候参数一致\n        changeName(value: string) {\n            super.changeName(value, 10)\n            // this.name = value;\n            return 'a'\n        }\n    }\n    const tom = new Cat('tom', 3);\n    tom.changeName('jerry');\n\n    class A {\n        // private 只能在类内部访问，子类不能访问，此时A不能被继承，也不能被new\n        // protected 只能在类和子类内部访问，此时A不能被new\n        protected constructor() { }\n    }\n    class B extends A {\n        constructor() {\n            super()\n        }\n    }\n\n    // private constructor可以在单例模式中使用，不在外部使用new关键字创建实例：\n    class Singleton {\n        static instance = new Singleton();\n        private constructor() { };\n        static getInstance() {\n            return this.instance\n        }\n    }\n    let instance = Singleton.getInstance();\n\n    // 不能被new的类，叫抽象类，在ts中使用 abstract 关键字\n    // 抽象类 可以含有非抽象的方法和属性\n    // 抽象类可以被继承\n    {\n        abstract class Animal {\n            public abstract a: string;//抽象属性\n            drink() {//非抽象方法\n                console.log('喝水')\n            }\n            abstract eat(): void;//抽象的方法，父类没有实现，子类必须实现\n        }\n        class Cat extends Animal {\n            public a!: string;\n            eat(): void {\n                console.log('吃东西')\n            }\n        }\n    }\n}","import baseType from './src/baseType';\nimport typeAsserts from './src/typeAsserts';\nimport functionType from './src/functionType';\nimport classType from './src/classType';\n\nbaseType()\ntypeAsserts()\nfunctionType()\nclassType()"],"names":[],"mappings":"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"}