/**
 * 打家劫舍
 * 你是一个经验丰富的小偷，准备偷沿街的一排房间，每个房间都存有一定的现金，为了防止被发现，你不能偷相邻的两家，
 * 即，如果偷了第一家，就不能再偷第二家；如果偷了第二家，那么就不能偷第一家和第三家。
 * 给定一个整数数组nums，数组中的元素表示每个房间存有的现金数额，请你计算在不被发现的前提下最多的偷窃金额。
 * 思路：
 * 1. 使用动态规划来解决这个问题。
 * 2. 定义一个数组dp，其中dp[i]表示偷窃到第i个房间时的最大金额。
 * 3. 对于每个房间i，有两种选择：偷窃当前房间或不偷窃当前房间。
 * 4. 如果偷窃当前房间，则最大金额为当前房间的现金加上前一个房间的最大金额（即dp[i-2]）。
 * 5. 如果不偷窃当前房间，则最大金额为前一个房间的最大金额（即dp[i-1]）。
 * 6. 因此，状态转移方程为：dp[i] = Math.max(dp[i-1], nums[i] + (i >= 2 ? dp[i-2] : 0))。
 * 7. 初始状态为dp[0] = nums[0]，dp[1] = Math.max(nums[0], nums[1])。
 * 8. 最终返回dp数组的最后一个元素，即为最大偷窃金额。
 * @param nums int整型一维数组 房间现金数额
 * @return int整型 最大偷窃金额
 */
function rob(nums) {
  if (nums.length <= 2) return Math.max(...nums, 0); // 如果房间数小于等于2，直接返回最大值
  const dp = new Array(nums.length).fill(0); // 初始化dp数组
  dp[0] = nums[0]; // 偷窃第一个房间
  dp[1] = Math.max(nums[0], nums[1]); // 偷窃第一个或第二个房间的最大现金
  for (let i = 2; i < nums.length; i++) {
    dp[i] = Math.max(dp[i - 1], nums[i] + dp[i - 2]); // 状态转移方程
  }
  return dp[nums.length - 1]; // 返回最大偷窃金额
}
