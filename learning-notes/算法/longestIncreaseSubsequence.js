/**
 * 最长严格上升子序列问题。
 * 题目描述：
 * 给定一个整数数组，求其中最长严格上升子序列的长度。
 * 严格上升子序列是指子序列中的元素严格递增。
 * 例如，给定数组 [10, 9, 2, 5, 3, 7, 101, 18]，最长严格上升子序列为 [2, 3, 7, 101]，长度为 4。
 * 该问题可以使用动态规划来解决。
 * 动态规划思路：
 * 1. 初始化一个 dp 数组，dp[i] 表示以 arr[i] 结尾的最长严格上升子序列的长度。
 * 2. 遍历数组，对于每个元素 arr[i]，遍历之前的元素 arr[j] (j < i)，
 *    如果 arr[j] < arr[i]，则可以将 arr[i] 添加到以 arr[j] 结尾的子序列中。
 *    更新 dp[i] = max(dp[i], dp[j] + 1)。
 * 3. 最终，最长严格上升子序列的长度为 dp 数组中的最大值。
 * 4. 时间复杂度为 O(n^2)，空间复杂度为 O(n)。
 * 给定数组的最长严格上升子序列的长度。
 * @param arr int整型一维数组 给定的数组
 * @return int整型
 */
function LIS(arr) {
  // write code here
  if (arr.length === 0) {
    return 0; // 如果数组为空，返回0
  }
  const dp = new Array(arr.length).fill(1); // 初始化 dp 数组，长度为 arr 的长度，初始值为 1
  for (let i = 0; i < arr.length; i++) {
    for (let j = 0; j < i; j++) {
      if (arr[j] < arr[i]) {
        // 与i之前的元素比较，如果 arr[j] < arr[i]，则可以将 arr[i] 添加到以 arr[j] 结尾的子序列中
        // 更新 dp[i] 为 dp[j] + 1 的最大值
        dp[i] = Math.max(dp[i], dp[j] + 1); // 更新 dp[i]
      }
    }
  }
  // console.log(Math.max(...dp));
  return Math.max(...dp); // 返回 dp 数组中的最大值，即最长严格上升子序列的长度
}
LIS([10, 9, 2, 5, 3, 7, 101, 18]); // 输出4
LIS([1, 3, 6, 7, 9, 4, 10, 5, 6]); // 输出6
LIS([3, 2]); // 输出1
LIS([1, 2, 3, 4, 5]); // 输出5
LIS([5, 4, 3, 2, 1]); // 输出1
