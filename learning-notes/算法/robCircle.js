/**
 * 打家劫舍
 * 你是一个经验丰富的小偷，准备偷沿街的一排房间，每个房间都存有一定的现金，为了防止被发现，你不能偷相邻的两家，
 * 即，如果偷了第一家，就不能再偷第二家；如果偷了第二家，那么就不能偷第一家和第三家。
 * 沿湖的房间组成一个闭合的圆形，即第一个房间和最后一个房间视为相邻。
 * 给定一个整数数组nums，数组中的元素表示每个房间存有的现金数额，请你计算在不被发现的前提下最多的偷窃金额。
 * 思路：
 * 1. 使用动态规划来解决这个问题。
 * 2. 定义两个dp数组，分别表示偷窃第一个房间和不偷窃第一个房间的最大金额。
 * 3. 对于每个房间i，有两种选择：偷窃当前房间或不偷窃当前房间。
 * 4. 如果偷窃当前房间，则最大金额为当前房间的现金加上前一个房间的最大金额（即dp[i-2]）。
 * 5. 如果不偷窃当前房间，则最大金额为前一个房间的最大金额（即dp[i-1]）。
 * 6. 因此，状态转移方程为：dp[i] = Math.max(dp[i-1], nums[i] + (i >= 2 ? dp[i-2] : 0))。
 * 7. 初始状态为dp[0] = nums[0]，dp[1] = Math.max(nums[0], nums[1])。
 * 8. 最终返回两个dp数组的最大值，即为最大偷窃金额。
 * @param nums int整型一维数组 房间现金数额
 * @return int整型 最大偷窃金额
 */
function rob(nums) {
  if (nums.length <= 2) return Math.max(...nums, 0); // 如果房间数小于等于2，直接返回最大值
  const dp1 = new Array(nums.length - 1).fill(0); // 不偷窃第一个房间的dp数组
  const dp2 = new Array(nums.length - 1).fill(0); // 偷窃第一个房间的dp数组
  dp1[0] = nums[1]; // 偷窃第二个房间
  dp1[1] = Math.max(nums[1], nums[2]); // 偷窃第二个或第三个房间的最大现金
  dp2[0] = nums[0]; // 偷窃第一个房间
  dp2[1] = Math.max(nums[0], nums[1]); // 偷窃第一个或第二个房间的最大现金
  for (let i = 2; i < nums.length - 1; i++) {
    dp1[i] = Math.max(dp1[i - 1], nums[i + 1] + dp1[i - 2]); // 状态转移方程，不偷窃第一个房间
    dp2[i] = Math.max(dp2[i - 1], nums[i] + dp2[i - 2]); // 状态转移方程，偷窃第一个房间
  }
  return Math.max(dp1[nums.length - 2], dp2[nums.length - 2]); // 返回两个dp数组的最大值
}
